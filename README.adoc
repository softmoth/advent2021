# Advent of Code 2021 exercises

The main site is https://adventofcode.com/2021[].

I was inspired to do it by
https://www.youtube.com/playlist?list=PLWtPciJ1UMuAJ-To7dMk71e-aiwBLg_Id[Chris Biscardi].

## Day 1

I learned `std::io::stdin().lines()`, which handles locking automatically in recent Rust.

Chris Biscardi introduced me to *dhat*, a very simple heap profiler. So far, that along with `/usr/bin/time` is enough to do some basic testing.

## Day 2

I rewrote this several times. First with a naÃ¯ve `split_whitespace()` parser, and then using `nom` (introduced by Chris Biscardi). Basically I copied his approach verbatim.

I did learn how to return an enum value from a function, and then call it later. The trick is to cast the enum value explicitly to `fn(i32) -> Command`. Otherwise it looks like `fn(i32) -> Command {Command::Down}` (i.e., it's too specific) and the compiler thinks each value is of a different type. That was satisfying to get working.

## Day 3

Working with BTreeSet was interesting. For part 1 (solution not kept) I just kept a count of how many entries had each bit set. But part 2 required storing all of the entries and whittling them down. At first I tried `.filter_drain()`, but then I found that an initial `.partition()` of the set allows the two questions to be answered without needing to duplicate any of the entries.

## Day 4

This is my first time actually working with *ndarray*. Once I figured out the basics, it was trivial to use `board.axis_iter()` to check both across and down. So it worked out well, and was good to get my feet wet with the library.

I'm starting to get used to *nom* for parsing text, and feel like I can get it into a data structure fairly efficiently, but I'm guessing there's a better way still. At first I used nested for loops and explict indexing into a `[u8;BOARD_SIZE]` fixed array. I had to use `fold_many_m_n()` in the inner loop to avoid `nom` allocating an intermediate `Vec`. Using vectors instead isn't too bad; it addsabout 50 bytes of allocation per board parsed. Mapping that with `Array::from_shape_vec()` adds another 200 bytes or so.

But it took me a while to get to compile with each change of organization. It's good practice for managing ownership, etc.

Part 2 was pretty straightforward. Instead of stopping after the first win, just process all of them. I kept every board that won, in order, then it's easy to grab the first and last for the answer.

// vim:set tw=0:
