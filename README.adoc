# Advent of Code 2021 exercises

The main site is https://adventofcode.com/2021[].

I was inspired to do it by
https://www.youtube.com/playlist?list=PLWtPciJ1UMuAJ-To7dMk71e-aiwBLg_Id[Chris Biscardi].


## Day 1

I learned `std::io::stdin().lines()`, which handles locking automatically in recent Rust.

Chris Biscardi introduced me to *dhat*, a very simple heap profiler. So far, that along with `/usr/bin/time` is enough to do some basic testing.


## Day 2

I rewrote this several times. First with a naÃ¯ve `split_whitespace()` parser, and then using `nom` (introduced by Chris Biscardi). Basically I copied his approach verbatim.

I did learn how to return an enum value from a function, and then call it later. The trick is to cast the enum value explicitly to `fn(i32) -> Command`. Otherwise it looks like `fn(i32) -> Command {Command::Down}` (i.e., it's too specific) and the compiler thinks each value is of a different type. That was satisfying to get working.


## Day 3

Working with BTreeSet was interesting. For part 1 (solution not kept) I just kept a count of how many entries had each bit set. But part 2 required storing all of the entries and whittling them down. At first I tried `.filter_drain()`, but then I found that an initial `.partition()` of the set allows the two questions to be answered without needing to duplicate any of the entries.


## Day 4

This is my first time actually working with *ndarray*. Once I figured out the basics, it was trivial to use `board.axis_iter()` to check both across and down. So it worked out well, and was good to get my feet wet with the library.

I'm starting to get used to *nom* for parsing text, and feel like I can get it into a data structure fairly efficiently, but I'm guessing there's a better way still. At first I used nested for loops and explicit indexing into a `[u8;BOARD_SIZE]` fixed array. I had to use `fold_many_m_n()` in the inner loop to avoid `nom` allocating an intermediate `Vec`. Using vectors instead isn't too bad; it adds about 50 bytes of allocation per board parsed. Mapping that with `Array::from_shape_vec()` adds another 200 bytes or so.

But it took me a while to get to compile with each change of organization. It's good practice for managing ownership, etc.

Part 2 was pretty straightforward. Instead of stopping after the first win, just process all of them. I kept every board that won, in order, then it's easy to grab the first and last for the answer.


## Day 5

Part one uses similar techniques to Day 4. Parsing with nom continues to be pleasant. I'm getting more familiar with ndarray.

Most of the awkwardness is that I'm still learning how to specify the types when needed, how to use the libraries, and so forth. For example, I spent a fair amount of time trying to understand why `.map_inplace()` wasn't getting a mutable ref to the value, even though I'd declared the array as `mut`. I realized I needed `.slice_mut()` instead of `.slice()`, which would be obvious to a more seasoned Rust developer.

I did a little bit of code organizing, while still keeping each day self-contained. Now `main` just slurps the input and shows the result of a `process()` function. All the guts are below the fold.

Part two doesn't add much interesting. I can't find a way to iterate over a diagonal slice in ndarray (`SliceInfoElem` sensibly doesn't handle that), so I just write the imperative loop explicitly.


## Day 6

For part 1, the parsing was trivial. The solution was pretty clear, but I wanted to avoid unnecessary copying, so instead of shifting or rotating a Vec of numbers, I made my own data structure to track the index. This means there's only a few simple additions needed, rather than moving N values. I guess with only 8 lifetimes, the copying would be minimal, but this felt right.

I thought of implementing Iterator for it, so I could do `school.iter().take(80).tail()` or similar, but that didn't really work out.




// vim:set spell tw=0:
